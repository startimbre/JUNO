package studyb;

/**
 * LESSON B-29
 * 「DATABASE」
 * DBにアクセスするメッソドのクラス
 * DBメッソドのリスト
 * ------------------------------------------------------
 * 接続、切断、コミット、ロールバック、更新(INSERT,UPDATE,DELETE)、表示
 * ------------------------------------------------------
 * B14_execで実行
 *
 * @author jin.junho(ジンジュンホ、800189)
 * @since 1.8
 */
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.ArrayList;

import com.mysql.jdbc.exceptions.jdbc4.MySQLIntegrityConstraintViolationException;
import com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;

public class B29_DBAccess{
	
	static final String JDBC_DRIVER = "com.mysql.jdbc.Driver";  
	static final String DB_URL = "jdbc:mysql://localhost/kadaidb?useSSL=false&useUnicode=yes&characterEncoding=UTF-8";
	static final String USERNAME = "root";
	static final String PASSWORD = "901214";
	
	private Connection conn = null;
	private PreparedStatement pstmt = null;
	private ResultSet rs = null;
	private int rowcnt = 0; // TABLE(ROW(行))の大きさを入れる変数
	private int colcnt = 0; // TABLE(COL(列))の大きさを入れる変数
	
	/**
	 * Connect.
	 * DBに接続、トランザクション開始
	 */
	
	public void connect() {
		try { // ドライバーローディンぐ
			Class.forName(JDBC_DRIVER);
			System.out.println("ドライバーローディンぐしました。");
		} catch (ClassNotFoundException e) {
			e.printStackTrace();
		}
		
		try { // DB接続
			conn = DriverManager.getConnection(DB_URL,USERNAME,PASSWORD);
			System.out.println("DBに接続しました。");
			conn.setAutoCommit(false);	// オートコミットを消しる
			System.out.println("AutoCommit OFF");
		}catch (SQLException se) {
			se.printStackTrace();
		}
	}

	/**
	 * Disconnect.
	 * DBから切断、トランザクション終了
	 */
	public void disconnect() {
		try {
			if( conn != null ) {
				conn.close();
			}
			if( rs != null ) {
				rs.close();
			}
			if( pstmt != null ) {
				pstmt.close();
			}
			System.out.println("DB EXIT");
		}catch (SQLException e) {
			System.out.println("データベースに切断エラー" + e);
		}
	}
	
	/**
	 * Commit.
	 * データを保存
	 */
	public void commit() {	
		try{
			conn.commit();
			System.out.println("データーをコミットしました。");
		}catch (SQLException e) {
			System.out.println("commitエラー" + e);
		}
	}

	public void rollback() {
		try{
			conn.rollback();
			System.out.println("データーをロールバックしました。");
		}catch (SQLException e) {
			System.out.println("rollbackエラー" + e);
		}
	}
	
	/**
	 * updateExec.
	 *　
	 *　INSERT 、UPDATE、DELETEを実行
	 * @param sql(SQL QUERYが入る引数)
	 * @return res(実行の判断をする戻り値）
	 */
	
	public int updateExec(String sql){
		int res = -1;
		try {
			pstmt = conn.prepareStatement(sql); 		
			res = pstmt.executeUpdate();
			System.out.println("testtable1が更新されました。");
			}
			// SQL文が間違ったとき例外処理
			catch(MySQLSyntaxErrorException syntaxError) { 
				System.out.println("### SQL QUERY エラー : SQL文を確認して入力してください。");
			}
			// PRIMARY KEYが重複した時の例外処理
			catch(MySQLIntegrityConstraintViolationException constraintError) {
				System.out.println("### INSERT エラー : PRIMARY　KEYが重複しています、データーを確認してください。");
			}
			catch(SQLException sqlError) {
				System.out.println("データー更新エラー" + sqlError);
			}
		return res;
	}

	/**
	 * selectExec.
	 *
	 *　Select文を実行 取得した値を戻す
	 * @param sql(SQL QUERYが入る引数)
	 * @return the string[][] 戻り値 取得した値（二次元配列)
	 */
	
	public String[][] selectExec(String sql){
		
		try {
			pstmt = conn.prepareStatement(sql);
			rs = pstmt.executeQuery();

			// COLの大きさ
		    ResultSetMetaData rsmd = rs.getMetaData();
		    colcnt = rsmd.getColumnCount(); // COLの値を入れる
		    
		    
		    
		    // ROWのおおきさ
			rs.last();   //　ROWのカーソルを最後に
			rowcnt = rs.getRow(); // ROWの値を入れる
			
			String[][] res = new String[5][10]; // String[行][列], res[3][10]	
			rs.beforeFirst(); // ROWのカーソルを最初に
			
			// TABLE[0からrowcnt][0]にTESTNOの全てのレコードの値を、
			// TABLE[0からrowcnt][1]にNAMEの全てのレコードの値を、
			// TABLE[0からrowcnt][2]にKANAの全てのレコードの値を、入れます。
			
			for(int i = 0; i < rowcnt; i++) {
				res[0][i] = rsmd.getColumnName(i+1);
			}
			int i = 0;
			while(rs.next()) {
				for(int j = 0; j < colcnt; j++) {
					res[j][i] = rs.getString(rsmd.getColumnName(j));
				}
				i++;
			}
			return res;
			
			
			
//		if(rs.next()){
//			for( int i = 0; i < rowcnt; i++) { // 1~3
//				for( int j = 0; j < colcnt; j++) { // 1~10
//					res[i][j] = rs.getString(rsmd.getColumnName(i));
//					System.out.println(res);
//				}
//			}
//		}
//		return res;		

//			for( int i = 0;i < rowcnt;i++ ) {
//				if( rs.next() ) {
//					if(rs.getString("TESTNO") != null) {
//						String tn = rs.getString("TESTNO");
//						res[i][0] = tn;
//					}
//					if(rs.getString("NAME") != null) {
//						String nm = rs.getString("NAME");
//						res[i][1] = nm;
//					}
//					if(rs.getString("KANA") != null) {
//						String kn = rs.getString("KANA");
//						res[i][2] = kn;
//					}
//				}
//			}
//			return res;
		} catch (SQLException e) {
			e.printStackTrace();
				return null;
		}
	}
	
	
	public String[][] selectExec(String sql, int arraySize){
		
		try {
			pstmt = conn.prepareStatement(sql);
			rs = pstmt.executeQuery();

			// COLの大きさ
		    ResultSetMetaData rsmd = rs.getMetaData();
		    colcnt = rsmd.getColumnCount(); // COLの値を入れる
		    
		    
		    
		    // ROWのおおきさ
			rs.last();   //　ROWのカーソルを最後に
			rowcnt = rs.getRow(); // ROWの値を入れる
			
			String[][] res = new String[rowcnt][colcnt]; // String[行][列], res[3][10]	
			rs.beforeFirst(); // ROWのカーソルを最初に
			
			// TABLE[0からrowcnt][0]にTESTNOの全てのレコードの値を、
			// TABLE[0からrowcnt][1]にNAMEの全てのレコードの値を、
			// TABLE[0からrowcnt][2]にKANAの全てのレコードの値を、入れます。
			
//			for(int i = 0; i < rowcnt; i++) {
//				res[0][i] = rsmd.getColumnName(i+1);
//			}
//			int i = 0;
			
			int count = 0;
			while(rs.next()) {
				if (colcnt >= 1) {
					String a = rs.getString(1);
					System.out.println(a);
					res[j][0] = a;
				}
				if (colcnt >= 2) {
					String b = rs.getString(2);
					System.out.println(b);
					res[j][1] = b;
				}
				if (colcnt >= 3) {
					String c = rs.getString(3);
					System.out.println(c);
					res[j][2] = c;
				}
				
//				for(int j = 0; j < colcnt; j++) {
//					String a = rs.getString(j);
//					res[j][i] = rs.getString(rsmd.getColumnName(j));
//				}
//				i++;
			}
			return res;
		} catch (SQLException e) {
			e.printStackTrace();
				return null;
		}
	}
	
	/**
	 * selectExec
	 *
	 *　Select文を実行 取得した値を戻す
	 * @param sql(SQL QUERYが入る引数)
	 * @param fromIdx SELECTの範囲(fromIdxまで探す）
	 * @return the string[][] 戻り値 取得した値（二次元配列)
	 */
	public String[][] selectExec(String sql, String searchRes){

		try {
			pstmt = conn.prepareStatement(sql);
			pstmt.setString(1, searchRes);
			rs = pstmt.executeQuery();

			// COLの大きさ
		    ResultSetMetaData rsmd = rs.getMetaData();
		    colcnt = rsmd.getColumnCount(); // COLの値を入れる
		    
		    // ROWのおおきさ
			rs.last();   //　ROWのカーソルを最後に
			rowcnt = rs.getRow(); // ROWの値を入れる
			
			String[][] res = new String[rowcnt][colcnt]; // String[行][列]		
			rs.beforeFirst(); // ROWのカーソルを最初に
			
			// TABLE[0からrowcnt][0]にTESTNOの全てのレコードの値を、
			// TABLE[0からrowcnt][1]にNAMEの全てのレコードの値を、
			// TABLE[0からrowcnt][2]にKANAの全てのレコードの値を、入れます。
				for( int i = 0;i < rowcnt;i++ ) {
					if( rs.next() ) {
						String tn = rs.getString("TESTNO");
						String nm = rs.getString("NAME");
						String kn = rs.getString("KANA");
						
						res[i][0] = tn;
						res[i][1] = nm;
						res[i][2] = kn;
					}
				}
				return res;
		} catch (SQLException e) {
			e.printStackTrace();
				return null;
		}
	}

	/**
	 * selectExec.
	 *
	 * @param sql(SQL QUERYが入る引数)
	 * @param fromIdx SELECTの範囲(fromIdxまで探す）
	 * @param toIdx SELECTの範囲(toIdxから探す）
	 * @return the string[][] 戻り値 取得した値（二次元配列)
	 */
	public String[][] selectExec(String sql, int fromIdx, int toIdx){

		try {
			pstmt = conn.prepareStatement(sql);
			pstmt.setInt(1, toIdx);
			pstmt.setInt(2, fromIdx);
			rs = pstmt.executeQuery();

			// COLの大きさ
		    ResultSetMetaData rsmd = rs.getMetaData();
		    colcnt = rsmd.getColumnCount(); // COLの値を入れる
		    
		    // ROWのおおきさ
			rs.last();   //　ROWのカーソルを最後に
			rowcnt = rs.getRow(); // ROWの値を入れる
			
			String[][] res = new String[rowcnt][colcnt]; // String[行][列]		
			rs.beforeFirst(); // ROWのカーソルを最初に
			
			// TABLE[0からrowcnt][0]にTESTNOの全てのレコードの値を、
			// TABLE[0からrowcnt][1]にNAMEの全てのレコードの値を、
			// TABLE[0からrowcnt][2]にKANAの全てのレコードの値を、入れます。
			for( int i = 0;i < rowcnt;i++ ) {
					if( rs.next() ) {
						String tn = rs.getString("TESTNO");
						String nm = rs.getString("NAME");
						String kn = rs.getString("KANA");
						
						res[i][0] = tn;
						res[i][1] = nm;
						res[i][2] = kn;
					}
				}
				return res;
		} catch (SQLException e) {
			e.printStackTrace();
				return null;
		}
	}
}